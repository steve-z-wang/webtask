{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"webtask","text":"<p>Easy-to-use LLM-powered browser automation \u2014 from autonomous tasks to element-level control.</p>"},{"location":"#why-webtask","title":"Why webtask?","text":"<ul> <li>High-level tasks: Describe what you want done \u2014 the agent figures out the steps</li> <li>Low-level control: Select any element with natural language \u2014 no CSS/XPath selectors needed</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from webtask import Webtask\nfrom webtask.integrations.llm import Gemini\n\nwt = Webtask()\nagent = await wt.create_agent(\n    llm=Gemini(model=\"gemini-2.5-flash\"),\n    wait_after_action=1.0,\n)\n\nawait agent.goto(\"https://practicesoftwaretesting.com\")\nawait agent.wait(3)\n\n# select: pick elements with natural language\nsearch = await agent.select(\"the search input\")\nawait search.fill(\"pliers\")\n\n# do: simple or complex tasks \u2014 agent figures out the steps\nawait agent.do(\"click search and add the first product to cart\")\n\n# extract: get structured data from the page\nprice = await agent.extract(\"the cart total price\")\n\n# verify: check conditions\nassert await agent.verify(\"cart has 1 item\")\n</code></pre>"},{"location":"#features","title":"Features","text":"<p>Four core operations</p> <pre><code>await agent.do(\"click search and add first product to cart\")  # Autonomous tasks\nelement = await agent.select(\"the search input\")              # Element selection\ndata = await agent.extract(\"the cart total\", MySchema)        # Data extraction\nassert await agent.verify(\"cart has 1 item\")                  # Verification\n</code></pre> <p>Stateful agents \u2014 Agent remembers context across tasks</p> <pre><code>await agent.do(\"Add pliers to cart\")\nawait agent.do(\"Add a hammer too\")  # Remembers previous action\nagent.clear_history()               # Reset when needed\n</code></pre> <p>Two modes \u2014 DOM-based or pixel-based interaction</p> <pre><code>agent = await wt.create_agent(llm=llm, mode=\"dom\")     # Element IDs (default)\nagent = await wt.create_agent(llm=llm, mode=\"pixel\")   # Screen coordinates\n</code></pre> <p>Browser integration \u2014 Works with new or existing browsers</p> <pre><code>agent = await wt.create_agent(llm=llm)                                  # New browser\nagent = await wt.create_agent_with_browser(llm=llm, browser=browser)    # Existing browser\nagent = wt.create_agent_with_context(llm=llm, context=context)          # Existing context\nagent = wt.create_agent_with_page(llm=llm, page=page)                   # Existing page\n</code></pre> <p>Error handling \u2014 Handle task failures gracefully</p> <pre><code>try:\n    await agent.do(\"Add item to cart\")\nexcept TaskAbortedError as e:\n    print(f\"Task failed: {e}\")\n</code></pre>"},{"location":"#get-started","title":"Get Started","text":"<ul> <li>Installation &amp; Getting Started</li> <li>Examples</li> <li>API Reference</li> <li>MCP Server</li> </ul>"},{"location":"architecture/","title":"Architecture","text":""},{"location":"architecture/#overview","title":"Overview","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Webtask    \u2502  Browser lifecycle management\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502 creates\n       \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502    Agent     \u2502  Task execution with LLM (text/visual/full mode)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502 uses\n       \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 TaskRunner   \u2502  Executes steps with tools\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502 controls\n       \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502AgentBrowser  \u2502  Page management, context building, coordinate scaling\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/#components","title":"Components","text":"<p>Webtask - Manages browser lifecycle, creates agents</p> <p>Agent - Main interface with <code>do()</code>, <code>verify()</code>, <code>extract()</code> methods. Supports three modes.</p> <p>TaskRunner - Executes tasks by calling LLM with available tools</p> <p>AgentBrowser - Manages pages, builds context (DOM and/or screenshots), scales coordinates</p>"},{"location":"architecture/#three-modes","title":"Three Modes","text":"<ul> <li>text - DOM-based tools (click, fill, type by element ID)</li> <li>visual - Pixel-based tools (click_at, type_text_at by coordinates)</li> <li>full - Both DOM and pixel tools</li> </ul>"},{"location":"architecture/#how-it-works","title":"How it Works","text":"<ol> <li>User calls <code>agent.do(\"task description\")</code></li> <li>TaskRunner builds context based on mode (DOM, screenshot, or both)</li> <li>LLM decides which tools to call</li> <li>TaskRunner executes tools via AgentBrowser</li> <li>Repeat until task complete or max steps reached</li> </ol>"},{"location":"architecture/#tools","title":"Tools","text":"<p>Common tools (all modes): - <code>goto</code> - Navigate to URL - <code>wait</code> - Wait for time - <code>go_back</code> / <code>go_forward</code> - Browser history - <code>complete_work</code> / <code>abort_work</code> - Task completion</p> <p>Text mode tools: - <code>click</code> - Click element by ID - <code>fill</code> - Fill form field by ID - <code>type</code> - Type into element by ID</p> <p>Visual mode tools: - <code>click_at</code> - Click at coordinates - <code>type_text_at</code> - Type at coordinates - <code>hover_at</code> - Hover at coordinates - <code>scroll_at</code> - Scroll at coordinates - <code>drag_and_drop</code> - Drag between coordinates</p>"},{"location":"architecture/#stateful-mode","title":"Stateful Mode","text":"<p>When <code>stateful=True</code> (default), Agent maintains conversation history across <code>do()</code> calls, allowing context to carry over between tasks.</p>"},{"location":"community/","title":"Community","text":"<p>Interested in contributing or collaborating on webtask?</p> <p>Please reach out via email, GitHub issues, or LinkedIn. I'd love to hear from you.</p>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#complete-workflow","title":"Complete Workflow","text":"<pre><code>import asyncio\nfrom webtask import Webtask\nfrom webtask.integrations.llm import Gemini\nfrom pydantic import BaseModel\n\nclass CartSummary(BaseModel):\n    item_count: int\n    total_price: float\n\nasync def main():\n    wt = Webtask()\n    agent = await wt.create_agent(\n        llm=Gemini(model=\"gemini-2.5-flash\"),\n        wait_after_action=1.0,  # Adjust for slower sites\n    )\n\n    # Navigate first\n    await agent.goto(\"https://practicesoftwaretesting.com\")\n    await agent.wait(3)\n\n    # do() - Execute tasks\n    await agent.do(\"Add 2 Flat-Head Wood Screws to the cart\")\n    await agent.do(\"Add 5 Cross-head screws to the cart\")\n    await agent.do(\"Go to the cart page\")\n\n    # extract() - Get structured data\n    summary = await agent.extract(\"cart summary\", CartSummary)\n    print(f\"Items: {summary.item_count}, Total: ${summary.total_price}\")\n\n    # verify() - Check conditions\n    verdict = await agent.verify(\"the cart contains 7 items\")\n    if verdict:\n        print(\"Cart verified!\")\n\n    await wt.close()\n\nasyncio.run(main())\n</code></pre>"},{"location":"examples/#element-selection","title":"Element Selection","text":"<p>Use <code>select()</code> to find elements with natural language and interact with them directly:</p> <pre><code>async def form_example():\n    wt = Webtask()\n    agent = await wt.create_agent(\n        llm=Gemini(model=\"gemini-2.5-flash\"),\n        wait_after_action=1.0,\n    )\n\n    await agent.goto(\"https://practicesoftwaretesting.com\")\n    await agent.wait(3)\n\n    # Select and use the search input\n    search_input = await agent.select(\"the search input field\")\n    await search_input.fill(\"screws\")\n\n    # Select and click the search button\n    search_btn = await agent.select(\"the search button\")\n    await search_btn.click()\n\n    await agent.wait(2)\n\n    # Select the first product\n    product = await agent.select(\"the first product in the list\")\n    await product.click()\n\n    await wt.close()\n</code></pre>"},{"location":"examples/#error-handling","title":"Error Handling","text":"<pre><code>from webtask import TaskAbortedError\n\ntry:\n    await agent.do(\"Add item to cart\")\nexcept TaskAbortedError as e:\n    print(f\"Task failed: {e}\")\n\ntry:\n    verdict = await agent.verify(\"cart has items\")\nexcept TaskAbortedError as e:\n    print(f\"Verification failed: {e}\")\n\ntry:\n    price = await agent.extract(\"total price\")\nexcept TaskAbortedError as e:\n    print(f\"Extraction failed: {e}\")\n</code></pre>"},{"location":"examples/#integration-with-existing-browser","title":"Integration with Existing Browser","text":"<pre><code>from playwright.async_api import async_playwright\nfrom webtask.integrations.llm import Gemini\n\nasync def with_existing_browser():\n    wt = Webtask()\n\n    async with async_playwright() as p:\n        browser = await p.chromium.launch(headless=False)\n        agent = await wt.create_agent_with_browser(\n            llm=Gemini(model=\"gemini-2.5-flash\"),\n            browser=browser,\n            wait_after_action=1.0,\n        )\n\n        await agent.goto(\"https://practicesoftwaretesting.com\")\n        await agent.wait(3)\n        await agent.do(\"add 2 screws to the cart\")\n\n        await browser.close()\n\nasyncio.run(with_existing_browser())\n</code></pre>"},{"location":"examples/#more-examples","title":"More Examples","text":"<p>See the examples directory for Jupyter notebooks.</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<pre><code>pip install pywebtask\nplaywright install chromium\n</code></pre>"},{"location":"getting-started/#first-task","title":"First Task","text":"<pre><code>import asyncio\nfrom webtask import Webtask\nfrom webtask.integrations.llm import Gemini\n\nasync def main():\n    wt = Webtask()\n    agent = await wt.create_agent(\n        llm=Gemini(model=\"gemini-2.5-flash\"),\n        wait_after_action=1.0,\n    )\n\n    await agent.goto(\"https://practicesoftwaretesting.com\")\n    await agent.wait(3)\n\n    # select: pick elements with natural language\n    search = await agent.select(\"the search input\")\n    await search.fill(\"pliers\")\n\n    # do: simple or complex tasks \u2014 agent figures out the steps\n    await agent.do(\"click search and add the first product to cart\")\n\n    # extract: get structured data from the page\n    price = await agent.extract(\"the cart total price\")\n    print(f\"Cart total: {price}\")\n\n    # verify: check conditions\n    assert await agent.verify(\"cart has 1 item\")\n\n    await wt.close()\n\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/#configuration","title":"Configuration","text":""},{"location":"getting-started/#two-modes","title":"Two Modes","text":"<pre><code>agent = await wt.create_agent(llm=llm, mode=\"dom\")     # Element IDs (default)\nagent = await wt.create_agent(llm=llm, mode=\"pixel\")   # Screen coordinates\n</code></pre>"},{"location":"getting-started/#headless-mode","title":"Headless Mode","text":"<pre><code>agent = await wt.create_agent(llm=llm, headless=False)  # Show browser (default)\nagent = await wt.create_agent(llm=llm, headless=True)   # Hide browser\n</code></pre>"},{"location":"getting-started/#stateful-agents","title":"Stateful Agents","text":"<pre><code># Agent remembers context across tasks by default\nawait agent.do(\"Add 2 screws to the cart\")\nawait agent.do(\"Add 5 more screws\")  # Remembers previous actions\nawait agent.do(\"Go to cart\")\n\nagent.clear_history()  # Start fresh when needed\n</code></pre>"},{"location":"getting-started/#element-selection","title":"Element Selection","text":"<p>Use <code>select()</code> to find elements using natural language and interact with them directly:</p> <pre><code># Select and click a button\nbutton = await agent.select(\"the login button\")\nawait button.click()\n\n# Select and fill an input field\nemail_field = await agent.select(\"email input\")\nawait email_field.fill(\"user@example.com\")\n\n# Select and interact with any element\nmenu = await agent.select(\"the navigation menu\")\nawait menu.click()\n</code></pre>"},{"location":"getting-started/#timing-control","title":"Timing Control","text":"<p>Important for Single Page Applications (SPAs)</p> <p>Modern websites often use SPAs where clicking a link changes content without a full page reload. The default <code>wait_after_action=1.0</code> second may not be enough for the new content to load, causing the agent to see stale DOM content and make incorrect decisions.</p> <p>Recommendation: For SPAs, increase <code>wait_after_action</code> to 2-3 seconds or use explicit waits.</p> <pre><code># Set default wait time for agent (default: 1.0s)\n# Increase for SPAs or slow-loading sites\nagent = await wt.create_agent(llm=llm, wait_after_action=3.0)\n\n# Override per task\nawait agent.do(\"Click submit\", wait_after_action=5.0)\n\n# Explicit waits\nawait agent.wait(3)                  # Simple wait (seconds)\nawait agent.wait_for_load()          # Wait for page load event\nawait agent.wait_for_network_idle()  # Wait for network idle (best for SPAs)\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Examples - See more usage examples</li> <li>API Reference - Full API documentation</li> </ul>"},{"location":"mcp-server/","title":"MCP Server","text":"<p>Work in progress - MCP server integration is currently under development.</p> <p>The webtask MCP (Model Context Protocol) server allows you to integrate web automation capabilities into Claude Desktop and other MCP-compatible clients.</p>"},{"location":"mcp-server/#installation","title":"Installation","text":"<pre><code>pip install pywebtask[mcp]\n</code></pre> <p>Requires Chrome or Chromium installed on your system.</p>"},{"location":"mcp-server/#configuration","title":"Configuration","text":"<p>Add to Claude Desktop configuration file:</p> <p>macOS: <code>~/Library/Application Support/Claude/claude_desktop_config.json</code></p> <p>Windows: <code>%APPDATA%/Claude/claude_desktop_config.json</code></p> <pre><code>{\n  \"mcpServers\": {\n    \"webtask\": {\n      \"command\": \"python\",\n      \"args\": [\"-m\", \"webtask.mcp_server\"]\n    }\n  }\n}\n</code></pre>"},{"location":"mcp-server/#setup","title":"Setup","text":"<ol> <li>Call the <code>onboard</code> tool in Claude Desktop</li> <li>Edit <code>~/.config/webtask/config.json</code> and add your Gemini API key</li> <li>Restart Claude Desktop</li> </ol>"},{"location":"mcp-server/#available-tools","title":"Available Tools","text":"<ul> <li><code>start_web_agent</code> - Start a new browser session</li> <li><code>do_web_task</code> - Execute a task with natural language</li> <li><code>close_web_agent</code> - Close a session</li> </ul>"},{"location":"mcp-server/#basic-usage","title":"Basic Usage","text":"<pre><code>Start a web agent session\nNavigate to Google and search for \"web automation\"\nClose the web agent session\n</code></pre>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#webtask","title":"Webtask","text":"<p>Manages browser lifecycle and creates agents.</p> <pre><code>wt = Webtask()\nagent = await wt.create_agent(llm=llm)\n</code></pre>"},{"location":"api/#agent","title":"Agent","text":"<p>Main interface for web automation.</p> <pre><code>await agent.goto(\"https://example.com\")\nawait agent.do(\"Click the login button\")\nverdict = await agent.verify(\"user is logged in\")\n</code></pre>"},{"location":"api/#browser","title":"Browser","text":"<p>Low-level browser components for advanced use cases.</p> <ul> <li>Browser - Browser lifecycle management</li> <li>Context - Isolated browsing sessions</li> <li>Page - Page operations</li> <li>Element - Element interactions</li> </ul>"},{"location":"api/#llm","title":"LLM","text":"<p>LLM providers and custom model integration.</p> <pre><code>from webtask.integrations.llm import Gemini\n\nllm = Gemini(model=\"gemini-2.5-flash\", api_key=os.getenv(\"GEMINI_API_KEY\"))\n</code></pre>"},{"location":"api/#result","title":"Result","text":"<p>Data classes returned by agent methods.</p> <ul> <li><code>Result</code> - Returned by <code>agent.do()</code></li> <li><code>Verdict</code> - Returned by <code>agent.verify()</code></li> <li><code>Status</code> - Task status enum</li> </ul>"},{"location":"api/agent/","title":"Agent","text":"<p>Main interface for web automation.</p>"},{"location":"api/agent/#constructor","title":"Constructor","text":"<pre><code>Agent(\n    llm: LLM,\n    context: Context,\n    mode: str = \"dom\",\n    wait_after_action: float = 1.0\n)\n</code></pre> <p>Parameters: - <code>llm</code> - LLM instance for reasoning - <code>context</code> - Browser context - <code>mode</code> - Agent mode: \"dom\" (element IDs) or \"pixel\" (screen coordinates) - <code>wait_after_action</code> - Default wait time after each action in seconds (default: 1.0)</p>"},{"location":"api/agent/#methods","title":"Methods","text":""},{"location":"api/agent/#do","title":"<code>do()</code>","text":"<pre><code>async def do(\n    task: str,\n    max_steps: int = 20,\n    wait_after_action: Optional[float] = None,\n    mode: Optional[str] = None,\n    files: Optional[List[str]] = None,\n    output_schema: Optional[Type[BaseModel]] = None,\n) -&gt; Result\n</code></pre> <p>Execute a task with natural language.</p> <p>Parameters: - <code>task</code> - Task description - <code>max_steps</code> - Maximum steps to execute (default: 20) - <code>wait_after_action</code> - Wait time after each action (uses agent default if not specified) - <code>mode</code> - Agent mode override: \"dom\" or \"pixel\" (uses agent default if not specified) - <code>files</code> - Optional list of file paths for upload - <code>output_schema</code> - Optional Pydantic model for structured output</p> <p>Returns: Result with optional output and feedback</p> <p>Raises: <code>TaskAbortedError</code> if task is aborted</p> <p>Example: <pre><code>result = await agent.do(\"Add 2 screws to the cart\")\nprint(result.feedback)\n\n# With structured output\nfrom pydantic import BaseModel\n\nclass ProductInfo(BaseModel):\n    name: str\n    price: float\n\nresult = await agent.do(\"Extract product info\", output_schema=ProductInfo)\nprint(f\"{result.output.name}: ${result.output.price}\")\n</code></pre></p>"},{"location":"api/agent/#verify","title":"<code>verify()</code>","text":"<pre><code>async def verify(\n    condition: str,\n    max_steps: int = 10,\n    wait_after_action: Optional[float] = None,\n    mode: Optional[str] = None,\n) -&gt; Verdict\n</code></pre> <p>Check if a condition is true.</p> <p>Parameters: - <code>condition</code> - Condition to check - <code>max_steps</code> - Maximum steps (default: 10) - <code>wait_after_action</code> - Wait time after each action (uses agent default if not specified) - <code>mode</code> - Agent mode override: \"dom\" or \"pixel\" (uses agent default if not specified)</p> <p>Returns: Verdict that can be used as boolean</p> <p>Raises: <code>TaskAbortedError</code> if verification is aborted</p> <p>Example: <pre><code>verdict = await agent.verify(\"the cart contains 7 items\")\n\nif verdict:\n    print(\"Success!\")\n\nassert verdict == True\n</code></pre></p>"},{"location":"api/agent/#extract","title":"<code>extract()</code>","text":"<pre><code>async def extract(\n    what: str,\n    output_schema: Optional[Type[BaseModel]] = None,\n    max_steps: int = 10,\n    wait_after_action: Optional[float] = None,\n    mode: Optional[str] = None,\n) -&gt; str | BaseModel\n</code></pre> <p>Extract information from the current page.</p> <p>Parameters: - <code>what</code> - What to extract in natural language - <code>output_schema</code> - Optional Pydantic model for structured output - <code>max_steps</code> - Maximum steps (default: 10) - <code>wait_after_action</code> - Wait time after each action (uses agent default if not specified) - <code>mode</code> - Agent mode override: \"dom\" or \"pixel\" (uses agent default if not specified)</p> <p>Returns: str if no output_schema provided, otherwise instance of output_schema</p> <p>Raises: <code>TaskAbortedError</code> if extraction is aborted</p> <p>Example: <pre><code># Simple string extraction\nprice = await agent.extract(\"total price\")\nprint(f\"Price: {price}\")\n\n# Structured extraction\nfrom pydantic import BaseModel\n\nclass ProductInfo(BaseModel):\n    name: str\n    price: float\n    in_stock: bool\n\nproduct = await agent.extract(\"product information\", ProductInfo)\nprint(f\"{product.name}: ${product.price}\")\n</code></pre></p>"},{"location":"api/agent/#goto","title":"<code>goto()</code>","text":"<pre><code>async def goto(url: str) -&gt; None\n</code></pre> <p>Navigate to a URL.</p> <p>Example: <pre><code>await agent.goto(\"example.com\")\n</code></pre></p>"},{"location":"api/agent/#screenshot","title":"<code>screenshot()</code>","text":"<pre><code>async def screenshot(\n    path: Optional[str] = None,\n    full_page: bool = False\n) -&gt; bytes\n</code></pre> <p>Take a screenshot of the current page.</p> <p>Parameters: - <code>path</code> - Optional file path to save screenshot - <code>full_page</code> - Screenshot the full scrollable page (default: False)</p> <p>Returns: Screenshot as bytes (PNG format)</p> <p>Example: <pre><code># Save to file\nawait agent.screenshot(\"page.png\")\n\n# Full page screenshot\nawait agent.screenshot(\"full.png\", full_page=True)\n\n# Get bytes without saving\nscreenshot_bytes = await agent.screenshot()\n</code></pre></p>"},{"location":"api/agent/#wait","title":"<code>wait()</code>","text":"<pre><code>async def wait(seconds: float) -&gt; None\n</code></pre> <p>Wait for a specific amount of time.</p> <p>Parameters: - <code>seconds</code> - Number of seconds to wait</p> <p>Example: <pre><code>await agent.wait(2.0)  # Wait 2 seconds\n</code></pre></p>"},{"location":"api/agent/#wait_for_load","title":"<code>wait_for_load()</code>","text":"<pre><code>async def wait_for_load(timeout: int = 10000) -&gt; None\n</code></pre> <p>Wait for the current page to fully load.</p> <p>Parameters: - <code>timeout</code> - Maximum time to wait in milliseconds (default: 10000ms = 10s)</p> <p>Raises: - <code>RuntimeError</code> if no page is active - <code>TimeoutError</code> if page doesn't load within timeout</p> <p>Example: <pre><code>await agent.goto(\"example.com\")\nawait agent.wait_for_load()\n</code></pre></p>"},{"location":"api/agent/#wait_for_network_idle","title":"<code>wait_for_network_idle()</code>","text":"<pre><code>async def wait_for_network_idle(timeout: int = 10000) -&gt; None\n</code></pre> <p>Wait for network to be idle (no requests for 500ms). Useful for SPAs and pages with AJAX requests.</p> <p>Parameters: - <code>timeout</code> - Maximum time to wait in milliseconds (default: 10000ms = 10s)</p> <p>Raises: - <code>RuntimeError</code> if no page is active - <code>TimeoutError</code> if network doesn't become idle within timeout</p> <p>Example: <pre><code>await agent.do(\"Click the search button\")\nawait agent.wait_for_network_idle()  # Wait for results to load\n</code></pre></p>"},{"location":"api/agent/#clear_history","title":"<code>clear_history()</code>","text":"<pre><code>def clear_history() -&gt; None\n</code></pre> <p>Clear conversation history. Resets the agent's memory of previous tasks, starting fresh.</p> <p>Example: <pre><code>await agent.do(\"Add item to cart\")\nawait agent.do(\"Checkout\")  # Agent remembers cart context\n\nagent.clear_history()  # Start fresh\n\nawait agent.do(\"Search for shoes\")  # No memory of previous tasks\n</code></pre></p>"},{"location":"api/agent/#get_debug_context","title":"<code>get_debug_context()</code>","text":"<pre><code>async def get_debug_context() -&gt; str\n</code></pre> <p>Get the text context that the LLM sees (for debugging). Returns the DOM snapshot and tabs context as a string. Useful for debugging when elements can't be found in text mode.</p> <p>Returns: The text representation of the current page state</p> <p>Example: <pre><code>context = await agent.get_debug_context()\nprint(context)  # See what the LLM sees\n</code></pre></p>"},{"location":"api/agent/#get_current_page","title":"<code>get_current_page()</code>","text":"<pre><code>def get_current_page() -&gt; Optional[Page]\n</code></pre> <p>Get the current active page.</p> <p>Returns: Current Page instance, or None if no page is active</p> <p>Example: <pre><code>page = agent.get_current_page()\nif page:\n    print(f\"Current URL: {page.url}\")\n</code></pre></p>"},{"location":"api/agent/#focus_tab","title":"<code>focus_tab()</code>","text":"<pre><code>def focus_tab(page: Page) -&gt; None\n</code></pre> <p>Focus a specific tab.</p> <p>Parameters: - <code>page</code> - Page instance to focus</p> <p>Example: <pre><code>pages = agent.browser.get_pages()\nagent.focus_tab(pages[0])  # Focus first tab\n</code></pre></p>"},{"location":"api/browser/","title":"Browser","text":"<p>Abstract base class for browser lifecycle management.</p>"},{"location":"api/browser/#class-methods","title":"Class Methods","text":""},{"location":"api/browser/#create","title":"<code>create()</code>","text":"<pre><code>@classmethod\nasync def create(cls, **kwargs) -&gt; Browser\n</code></pre> <p>Create and launch a new browser instance.</p> <p>Example: <pre><code>from webtask.integrations.browser.playwright import PlaywrightBrowser\n\nbrowser = await PlaywrightBrowser.create(headless=True)\n</code></pre></p>"},{"location":"api/browser/#connect","title":"<code>connect()</code>","text":"<pre><code>@classmethod\nasync def connect(cls, **kwargs) -&gt; Browser\n</code></pre> <p>Connect to an existing browser instance.</p> <p>Example: <pre><code>browser = await PlaywrightBrowser.connect(\"http://localhost:9222\")\n</code></pre></p>"},{"location":"api/browser/#properties","title":"Properties","text":""},{"location":"api/browser/#contexts","title":"<code>contexts</code>","text":"<pre><code>contexts: List[Context]\n</code></pre> <p>Get all existing browser contexts.</p> <p>Example: <pre><code>browser = await PlaywrightBrowser.connect(\"http://localhost:9222\")\nexisting_contexts = browser.contexts\n</code></pre></p>"},{"location":"api/browser/#methods","title":"Methods","text":""},{"location":"api/browser/#get_default_context","title":"<code>get_default_context()</code>","text":"<pre><code>def get_default_context() -&gt; Optional[Context]\n</code></pre> <p>Get the default (first) existing context, or None if no contexts exist.</p> <p>Example: <pre><code>browser = await PlaywrightBrowser.connect(\"http://localhost:9222\")\ncontext = browser.get_default_context()\n</code></pre></p>"},{"location":"api/browser/#create_context","title":"<code>create_context()</code>","text":"<pre><code>async def create_context(**kwargs) -&gt; Context\n</code></pre> <p>Create a new browser context.</p> <p>Example: <pre><code>browser = await PlaywrightBrowser.create()\ncontext = await browser.create_context()\n</code></pre></p>"},{"location":"api/browser/#close","title":"<code>close()</code>","text":"<pre><code>async def close() -&gt; None\n</code></pre> <p>Close the browser instance.</p> <p>Example: <pre><code>await browser.close()\n</code></pre></p>"},{"location":"api/context/","title":"Context","text":"<p>Abstract base class for browser context management.</p> <p>A context is an isolated browsing session with its own cookies and storage. Equivalent to Playwright's BrowserContext.</p>"},{"location":"api/context/#properties","title":"Properties","text":""},{"location":"api/context/#pages","title":"<code>pages</code>","text":"<pre><code>pages: List[Page]\n</code></pre> <p>Get all existing pages in this context.</p> <p>Example: <pre><code>context = await browser.create_context()\nexisting_pages = context.pages\nprint(f\"Number of pages: {len(existing_pages)}\")\n</code></pre></p>"},{"location":"api/context/#methods","title":"Methods","text":""},{"location":"api/context/#create_page","title":"<code>create_page()</code>","text":"<pre><code>async def create_page() -&gt; Page\n</code></pre> <p>Create a new page/tab in this context.</p> <p>Example: <pre><code>context = await browser.create_context()\npage = await context.create_page()\nawait page.navigate(\"https://example.com\")\n</code></pre></p>"},{"location":"api/context/#close","title":"<code>close()</code>","text":"<pre><code>async def close() -&gt; None\n</code></pre> <p>Close the context and all its pages.</p> <p>Example: <pre><code>await context.close()\n</code></pre></p>"},{"location":"api/context/#complete-example","title":"Complete Example","text":"<pre><code>from webtask.integrations.browser.playwright import PlaywrightBrowser\n\n# Create browser and context\nbrowser = await PlaywrightBrowser.create(headless=False)\ncontext = await browser.create_context()\n\n# Create pages\npage1 = await context.create_page()\npage2 = await context.create_page()\n\nawait page1.navigate(\"https://example.com\")\nawait page2.navigate(\"https://google.com\")\n\n# Check all pages\nprint(f\"Total pages: {len(context.pages)}\")\n\n# Cleanup\nawait context.close()\nawait browser.close()\n</code></pre>"},{"location":"api/data-classes/","title":"Data Classes","text":"<p>Result - Returned by <code>agent.do()</code></p> <pre><code>@dataclass\nclass Result:\n    status: Optional[Status]\n    output: Optional[Any]\n    feedback: Optional[str]\n</code></pre> <p>Verdict - Returned by <code>agent.verify()</code></p> <pre><code>@dataclass\nclass Verdict:\n    passed: bool\n    feedback: str\n    status: Status\n</code></pre> <p>Can be used as boolean:</p> <pre><code>verdict = await agent.verify(\"the cart contains 2 items\")\n\nif verdict:\n    print(\"Success!\")\n</code></pre> <p>Status - Task status enum</p> <pre><code>class Status(str, Enum):\n    COMPLETED = \"completed\"\n    ABORTED = \"aborted\"\n</code></pre>"},{"location":"api/element/","title":"Element","text":"<p>Abstract base class for browser element.</p> <p>Simple adapter over browser automation library elements (Playwright, Selenium, etc.). Typically obtained via <code>agent.select()</code> or <code>page.select_one()</code>.</p>"},{"location":"api/element/#action-methods","title":"Action Methods","text":""},{"location":"api/element/#click","title":"<code>click()</code>","text":"<pre><code>async def click() -&gt; None\n</code></pre> <p>Click the element.</p> <p>Example: <pre><code>button = await agent.select(\"submit button\")\nawait button.click()\n</code></pre></p>"},{"location":"api/element/#fill","title":"<code>fill()</code>","text":"<pre><code>async def fill(text: str) -&gt; None\n</code></pre> <p>Fill the element with text (for input fields). Sets value instantly.</p> <p>Parameters: - <code>text</code> (str): Text to fill</p> <p>Example: <pre><code>input_field = await agent.select(\"email input\")\nawait input_field.fill(\"user@example.com\")\n</code></pre></p>"},{"location":"api/element/#type","title":"<code>type()</code>","text":"<pre><code>async def type(text: str, delay: float = None) -&gt; None\n</code></pre> <p>Type text into the element character by character.</p> <p>Parameters: - <code>text</code> (str): Text to type - <code>delay</code> (float): Delay between keystrokes in milliseconds (None = instant)</p> <p>Example: <pre><code>input_field = await agent.select(\"search box\")\nawait input_field.type(\"web automation\", delay=80)  # More realistic\n</code></pre></p> <p>Comparison: fill() vs type() <pre><code># fill() - Instant, direct value setting\nawait input_field.fill(\"web automation\")  # Fast\n\n# type() - Character-by-character with delays\nawait input_field.type(\"web automation\", delay=80)  # Slower, more realistic\n</code></pre></p> <p>Use <code>fill()</code> for speed, <code>type()</code> for simulating human-like interaction.</p>"},{"location":"api/element/#upload_file","title":"<code>upload_file()</code>","text":"<pre><code>async def upload_file(file_path: Union[str, List[str]]) -&gt; None\n</code></pre> <p>Upload file(s) to a file input element.</p> <p>Parameters: - <code>file_path</code> (Union[str, List[str]]): Single file path (str) or multiple file paths (List[str])</p> <p>Example: <pre><code># Single file\nfile_input = await agent.select(\"file upload input\")\nawait file_input.upload_file(\"/path/to/file.pdf\")\n\n# Multiple files\nawait file_input.upload_file([\n    \"/path/to/file1.pdf\",\n    \"/path/to/file2.png\"\n])\n</code></pre></p>"},{"location":"api/element/#inspection-methods","title":"Inspection Methods","text":""},{"location":"api/element/#get_tag_name","title":"<code>get_tag_name()</code>","text":"<pre><code>async def get_tag_name() -&gt; str\n</code></pre> <p>Get the tag name of the element.</p> <p>Returns: Tag name (e.g., 'input', 'button', 'a')</p> <p>Example: <pre><code>element = await agent.select(\"submit button\")\ntag = await element.get_tag_name()\nprint(f\"Tag: {tag}\")  # \"button\"\n</code></pre></p>"},{"location":"api/element/#get_attribute","title":"<code>get_attribute()</code>","text":"<pre><code>async def get_attribute(name: str) -&gt; Optional[str]\n</code></pre> <p>Get an attribute value from the element.</p> <p>Parameters: - <code>name</code> (str): Attribute name (e.g., 'type', 'id', 'class')</p> <p>Returns: Attribute value or None if not present</p> <p>Example: <pre><code>input_field = await agent.select(\"email input\")\ninput_type = await input_field.get_attribute(\"type\")\nprint(f\"Input type: {input_type}\")  # \"email\"\n\nplaceholder = await input_field.get_attribute(\"placeholder\")\n</code></pre></p>"},{"location":"api/element/#get_attributes","title":"<code>get_attributes()</code>","text":"<pre><code>async def get_attributes() -&gt; Dict[str, str]\n</code></pre> <p>Get all attributes from the element.</p> <p>Returns: Dictionary of attribute name-value pairs</p> <p>Example: <pre><code>element = await agent.select(\"submit button\")\nattrs = await element.get_attributes()\n\nprint(f\"ID: {attrs.get('id')}\")\nprint(f\"Class: {attrs.get('class')}\")\nprint(f\"Type: {attrs.get('type')}\")\n</code></pre></p>"},{"location":"api/element/#get_html","title":"<code>get_html()</code>","text":"<pre><code>async def get_html(outer: bool = True) -&gt; str\n</code></pre> <p>Get the HTML content of the element.</p> <p>Parameters: - <code>outer</code> (bool): If True, returns outerHTML (includes the element itself). If False, returns innerHTML (only the element's content)</p> <p>Returns: HTML string</p> <p>Example: <pre><code>element = await agent.select(\"main content div\")\n\n# Get outer HTML (includes the div tag)\nouter_html = await element.get_html(outer=True)\n\n# Get inner HTML (only the content inside the div)\ninner_html = await element.get_html(outer=False)\n</code></pre></p>"},{"location":"api/element/#get_parent","title":"<code>get_parent()</code>","text":"<pre><code>async def get_parent() -&gt; Optional[Element]\n</code></pre> <p>Get the parent element.</p> <p>Returns: Parent Element or None if no parent (e.g., root element)</p> <p>Example: <pre><code>button = await agent.select(\"submit button\")\nparent = await button.get_parent()\n\nif parent:\n    parent_tag = await parent.get_tag_name()\n    print(f\"Parent tag: {parent_tag}\")\n</code></pre></p>"},{"location":"api/element/#get_children","title":"<code>get_children()</code>","text":"<pre><code>async def get_children() -&gt; List[Element]\n</code></pre> <p>Get all direct child elements.</p> <p>Returns: List of child Elements (may be empty)</p> <p>Example: <pre><code>container = await agent.select(\"main navigation\")\nchildren = await container.get_children()\nprint(f\"Number of children: {len(children)}\")\n\nfor child in children:\n    tag = await child.get_tag_name()\n    print(f\"  Child: {tag}\")\n</code></pre></p>"},{"location":"api/element/#complete-example","title":"Complete Example","text":"<pre><code>from webtask import Webtask\nfrom webtask.integrations.llm import GeminiLLM\n\nasync def main():\n    wt = Webtask(headless=False)\n    llm = GeminiLLM.create(model=\"gemini-2.5-flash\")\n    agent = await wt.create_agent(llm=llm)\n\n    await agent.navigate(\"https://example.com\")\n\n    # Select element\n    input_field = await agent.select(\"email input\")\n\n    # Inspect element\n    tag = await input_field.get_tag_name()\n    attrs = await input_field.get_attributes()\n    print(f\"Tag: {tag}, Attributes: {attrs}\")\n\n    # Interact with element\n    await input_field.type(\"user@example.com\", delay=80)\n\n    # Click submit\n    button = await agent.select(\"submit button\")\n    await button.click()\n\n    await wt.close()\n</code></pre>"},{"location":"api/llm/","title":"LLM","text":""},{"location":"api/llm/#gemini","title":"Gemini","text":"<pre><code>from webtask.integrations.llm import Gemini\n\nllm = Gemini(model=\"gemini-2.5-flash\")\nagent = await wt.create_agent(llm=llm, mode=\"text\")\n</code></pre>"},{"location":"api/llm/#geminicomputeruse","title":"GeminiComputerUse","text":"<p>For visual mode with pixel-based interactions:</p> <pre><code>from webtask.integrations.llm import GeminiComputerUse\n\nllm = GeminiComputerUse(model=\"gemini-2.5-computer-use-preview\")\nagent = await wt.create_agent(llm=llm, mode=\"visual\")\n</code></pre>"},{"location":"api/llm/#bedrock-wip","title":"Bedrock (WIP)","text":"<pre><code>from webtask.integrations.llm import Bedrock\n\nllm = Bedrock(model=\"anthropic.claude-sonnet-4-20250514-v1:0\")\nagent = await wt.create_agent(llm=llm)\n</code></pre>"},{"location":"api/llm/#custom-llm","title":"Custom LLM","text":"<p>To use your own model, implement the <code>LLM</code> base class:</p> <pre><code>from webtask.llm import LLM\nfrom webtask.llm.message import Message, AssistantMessage\nfrom webtask.llm.tool import Tool\nfrom typing import List\n\nclass CustomLLM(LLM):\n    async def call_tools(\n        self,\n        messages: List[Message],\n        tools: List[Tool],\n    ) -&gt; AssistantMessage:\n        # Your implementation here\n        # Convert messages to your API format\n        # Call your LLM API\n        # Convert response to AssistantMessage\n        pass\n\n# Use it\nllm = CustomLLM()\nagent = await wt.create_agent(llm=llm)\n</code></pre>"},{"location":"api/page/","title":"Page","text":"<p>Abstract base class for browser page management.</p>"},{"location":"api/page/#properties","title":"Properties","text":""},{"location":"api/page/#url","title":"<code>url</code>","text":"<pre><code>url: str\n</code></pre> <p>Get current page URL.</p>"},{"location":"api/page/#methods","title":"Methods","text":""},{"location":"api/page/#navigate","title":"<code>navigate()</code>","text":"<pre><code>async def navigate(url: str) -&gt; None\n</code></pre> <p>Navigate to a URL.</p>"},{"location":"api/page/#select","title":"<code>select()</code>","text":"<pre><code>async def select(selector: str) -&gt; List[Element]\n</code></pre> <p>Select all elements matching the selector.</p> <p>Parameters: - <code>selector</code> - CSS selector or XPath string</p> <p>Returns: List of Elements (may be empty)</p>"},{"location":"api/page/#select_one","title":"<code>select_one()</code>","text":"<pre><code>async def select_one(selector: str) -&gt; Element\n</code></pre> <p>Select a single element matching the selector.</p> <p>Parameters: - <code>selector</code> - CSS selector or XPath string</p> <p>Raises: ValueError if no elements match or multiple elements match</p>"},{"location":"api/page/#wait_for_load","title":"<code>wait_for_load()</code>","text":"<pre><code>async def wait_for_load(timeout: int = 10000) -&gt; None\n</code></pre> <p>Wait for page to fully load.</p> <p>Parameters: - <code>timeout</code> - Maximum time to wait in milliseconds (default: 10000)</p>"},{"location":"api/page/#screenshot","title":"<code>screenshot()</code>","text":"<pre><code>async def screenshot(\n    path: Optional[str] = None,\n    full_page: bool = False\n) -&gt; bytes\n</code></pre> <p>Take a screenshot of the current page.</p> <p>Parameters: - <code>path</code> - Optional file path to save screenshot - <code>full_page</code> - Screenshot the full scrollable page (default: False)</p> <p>Returns: Screenshot as bytes (PNG format)</p>"},{"location":"api/page/#keyboard_type","title":"<code>keyboard_type()</code>","text":"<pre><code>async def keyboard_type(\n    text: str,\n    clear: bool = False,\n    delay: float = 80\n) -&gt; None\n</code></pre> <p>Type text using keyboard into the currently focused element.</p> <p>Parameters: - <code>text</code> - Text to type - <code>clear</code> - Clear existing text before typing (default: False) - <code>delay</code> - Delay between keystrokes in milliseconds (default: 80)</p>"},{"location":"api/page/#evaluate","title":"<code>evaluate()</code>","text":"<pre><code>async def evaluate(script: str) -&gt; Any\n</code></pre> <p>Execute JavaScript in the page context.</p> <p>Parameters: - <code>script</code> - JavaScript code to execute</p> <p>Returns: Result of the script execution (JSON-serializable values)</p>"},{"location":"api/page/#get_cdp_dom_snapshot","title":"<code>get_cdp_dom_snapshot()</code>","text":"<pre><code>async def get_cdp_dom_snapshot() -&gt; Dict[str, Any]\n</code></pre> <p>Get a CDP DOM snapshot of the current page.</p> <p>Returns: CDP DOM snapshot data</p>"},{"location":"api/page/#get_cdp_accessibility_tree","title":"<code>get_cdp_accessibility_tree()</code>","text":"<pre><code>async def get_cdp_accessibility_tree() -&gt; Dict[str, Any]\n</code></pre> <p>Get a CDP accessibility tree of the current page.</p> <p>Returns: CDP accessibility tree data</p>"},{"location":"api/page/#close","title":"<code>close()</code>","text":"<pre><code>async def close() -&gt; None\n</code></pre> <p>Close the page.</p>"},{"location":"api/webtask/","title":"Webtask","text":"<p>Manages browser lifecycle and creates agents. Browser launches lazily on first agent creation.</p>"},{"location":"api/webtask/#constructor","title":"Constructor","text":"<pre><code>Webtask()\n</code></pre> <p>No parameters. Browser launches automatically when you create the first agent.</p>"},{"location":"api/webtask/#methods","title":"Methods","text":""},{"location":"api/webtask/#create_agent","title":"<code>create_agent()</code>","text":"<pre><code>async def create_agent(\n    llm: LLM,\n    mode: str = \"dom\",\n    wait_after_action: float = 1.0,\n    headless: bool = False,\n    browser_type: str = \"chromium\"\n) -&gt; Agent\n</code></pre> <p>Create agent with new browser context.</p> <p>Parameters: - <code>llm</code> - LLM instance (Gemini, GeminiComputerUse, or Bedrock) - <code>mode</code> - Agent mode: \"dom\" (element IDs) or \"pixel\" (screen coordinates) - <code>wait_after_action</code> - Wait time in seconds after each action (default: 1.0) - <code>headless</code> - Run browser without GUI (default: False) - <code>browser_type</code> - \"chromium\", \"firefox\", or \"webkit\" (default: \"chromium\")</p> <p>Example: <pre><code>from webtask import Webtask\nfrom webtask.integrations.llm import GeminiComputerUse\n\nwt = Webtask()\n\nagent = await wt.create_agent(llm=GeminiComputerUse(), mode=\"pixel\")\nagent = await wt.create_agent(llm=llm, mode=\"dom\", headless=True)\nagent = await wt.create_agent(llm=llm, wait_after_action=2.0)  # Slower network\n</code></pre></p>"},{"location":"api/webtask/#create_agent_with_browser","title":"<code>create_agent_with_browser()</code>","text":"<pre><code>async def create_agent_with_browser(\n    llm: LLM,\n    browser: Browser,\n    mode: str = \"dom\",\n    wait_after_action: float = 1.0,\n    use_existing_context: bool = True\n) -&gt; Agent\n</code></pre> <p>Create agent with existing browser.</p> <p>Example: <pre><code>from webtask.integrations.browser.playwright import PlaywrightBrowser\n\nbrowser = await PlaywrightBrowser.connect(\"http://localhost:9222\")\nagent = await wt.create_agent_with_browser(llm=llm, browser=browser, mode=\"pixel\")\n</code></pre></p>"},{"location":"api/webtask/#create_agent_with_context","title":"<code>create_agent_with_context()</code>","text":"<pre><code>def create_agent_with_context(\n    llm: LLM,\n    context: Context,\n    mode: str = \"dom\",\n    wait_after_action: float = 1.0\n) -&gt; Agent\n</code></pre> <p>Create agent with existing context.</p> <p>Example: <pre><code>context = browser.get_default_context()\nagent = wt.create_agent_with_context(llm=llm, context=context, mode=\"dom\")\n</code></pre></p>"},{"location":"api/webtask/#create_agent_with_page","title":"<code>create_agent_with_page()</code>","text":"<pre><code>def create_agent_with_page(\n    llm: LLM,\n    page: Page,\n    mode: str = \"text\",\n    wait_after_action: float = 1.0\n) -&gt; Agent\n</code></pre> <p>Create agent with existing page.</p> <p>Example: <pre><code>page = await context.create_page()\nagent = wt.create_agent_with_page(llm=llm, page=page, mode=\"pixel\")\n</code></pre></p>"},{"location":"api/webtask/#close","title":"<code>close()</code>","text":"<pre><code>async def close() -&gt; None\n</code></pre> <p>Close and cleanup all resources.</p> <p>Example: <pre><code>await wt.close()\n</code></pre></p>"},{"location":"guides/cookies/","title":"Using Cookies","text":""},{"location":"guides/cookies/#load-cookies-from-file","title":"Load Cookies from File","text":"<pre><code>from webtask import Webtask\nfrom webtask.integrations.llm import Gemini\nimport json\nimport os\n\n# Load cookies from JSON file\nwith open(\"cookies.json\", \"r\") as f:\n    cookies = json.load(f)\n\nwt = Webtask()\nllm = Gemini(model=\"gemini-2.5-flash\", api_key=os.getenv(\"GEMINI_API_KEY\"))\n\n# Create agent with cookies\nagent = await wt.create_agent(llm=llm, cookies=cookies)\n\nawait agent.goto(\"https://example.com\")\n# You're already logged in!\n</code></pre>"},{"location":"guides/cookies/#cookie-format","title":"Cookie Format","text":"<p>Cookies should be a list of dictionaries with these fields:</p> <pre><code>cookies = [\n    {\n        \"name\": \"session_id\",\n        \"value\": \"abc123\",\n        \"domain\": \".example.com\",\n        \"path\": \"/\",\n        \"secure\": True,\n        \"httpOnly\": True,\n    }\n]\n</code></pre>"},{"location":"guides/cookies/#save-cookies","title":"Save Cookies","text":"<pre><code># Get cookies from agent's session\nsession = agent._browser._session\ncookies = await session.get_cookies()\n\n# Save to file\nwith open(\"cookies.json\", \"w\") as f:\n    json.dump(cookies, f, indent=2)\n</code></pre>"},{"location":"guides/cookies/#use-case-persistent-login","title":"Use Case: Persistent Login","text":"<pre><code>import json\nimport os\nfrom pathlib import Path\n\nCOOKIES_FILE = Path(\"session_cookies.json\")\n\nasync def create_agent_with_session():\n    wt = Webtask()\n    llm = Gemini(model=\"gemini-2.5-flash\", api_key=os.getenv(\"GEMINI_API_KEY\"))\n\n    # Load cookies if they exist\n    cookies = None\n    if COOKIES_FILE.exists():\n        with open(COOKIES_FILE) as f:\n            cookies = json.load(f)\n\n    agent = await wt.create_agent(llm=llm, cookies=cookies)\n\n    return agent, wt\n\nasync def save_session(agent):\n    session = agent._browser._session\n    cookies = await session.get_cookies()\n\n    with open(COOKIES_FILE, \"w\") as f:\n        json.dump(cookies, f, indent=2)\n\n# Usage\nagent, wt = await create_agent_with_session()\n\nawait agent.goto(\"https://example.com\")\n\n# If not logged in, login\nif not await agent.verify(\"user is logged in\"):\n    await agent.do(\"Login with email test@example.com and password pass123\")\n    await save_session(agent)  # Save cookies for next time\n\n# Now you're logged in\nawait agent.do(\"Go to dashboard\")\n\nawait wt.close()\n</code></pre>"},{"location":"guides/custom-llm/","title":"Using Custom LLM","text":"<p>You can use any LLM by implementing the <code>LLM</code> base class.</p>"},{"location":"guides/custom-llm/#basic-implementation","title":"Basic Implementation","text":"<pre><code>from webtask.llm import LLM\nfrom webtask.llm.message import Message, AssistantMessage, TextContent\nfrom webtask.llm.tool import Tool, ToolCall\nfrom typing import List\n\nclass CustomLLM(LLM):\n    def __init__(self, api_key: str, model: str):\n        super().__init__()\n        self.api_key = api_key\n        self.model = model\n        # Initialize your LLM client here\n\n    async def call_tools(\n        self,\n        messages: List[Message],\n        tools: List[Tool],\n    ) -&gt; AssistantMessage:\n        # 1. Convert messages to your API format\n        api_messages = self._convert_messages(messages)\n\n        # 2. Convert tools to your API format\n        api_tools = self._convert_tools(tools)\n\n        # 3. Call your LLM API\n        response = await your_llm_api.generate(\n            messages=api_messages,\n            tools=api_tools,\n        )\n\n        # 4. Convert response to AssistantMessage\n        return self._convert_response(response)\n\n    def _convert_messages(self, messages: List[Message]) -&gt; list:\n        # Convert webtask messages to your API format\n        pass\n\n    def _convert_tools(self, tools: List[Tool]) -&gt; list:\n        # Convert webtask tools to your API format\n        pass\n\n    def _convert_response(self, response) -&gt; AssistantMessage:\n        # Convert your API response to AssistantMessage\n        # Return AssistantMessage with tool_calls\n        pass\n</code></pre>"},{"location":"guides/custom-llm/#using-your-custom-llm","title":"Using Your Custom LLM","text":"<pre><code>from webtask import Webtask\n\nwt = Webtask()\nllm = CustomLLM(api_key=\"your-key\", model=\"your-model\")\nagent = await wt.create_agent(llm=llm)\n\nawait agent.goto(\"https://example.com\")\nawait agent.do(\"Click the login button\")\n</code></pre>"},{"location":"guides/custom-llm/#reference-implementation","title":"Reference Implementation","text":"<p>See the Gemini implementation for a complete example:</p> <pre><code>src/webtask/integrations/llm/google/gemini.py\n</code></pre>"}]}